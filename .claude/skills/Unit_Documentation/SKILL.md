---
name: Unit_Documentation
description: Creates inline documentation for components, modules, hooks, and other code units as `<unit_name>_readme.md` files placed alongside the code they document
model: sonnet
allowed-tools: Bash, Edit, Read, Write
hooks:
  PreToolUse:
    - matcher: "*"
      once: true
      hooks:
        - type: command
          command: "$CLAUDE_PROJECT_DIR/.claude/hooks/log-lifecycle.sh" skill Unit_Documentation started '{"stage": "utility"}'
  Stop:
    - hooks:
        - type: command
          command: "$CLAUDE_PROJECT_DIR/.claude/hooks/log-lifecycle.sh" skill Unit_Documentation ended '{"stage": "utility"}'
---

## FIRST ACTION (MANDATORY)

Before doing ANYTHING else, run this command:

```bash
"$CLAUDE_PROJECT_DIR/.claude/hooks/log-lifecycle.sh" skill Unit_Documentation instruction_start '{"stage": "utility", "method": "instruction-based"}'
```

---

# Unit Documentation Skill

Creates documentation files alongside the code they document, following the pattern `<unit_name>_readme.md`.

## Purpose

Keep documentation close to code for better maintainability, discoverability, and accuracy. When documentation lives next to the code it describes, it's more likely to be updated when the code changes.

## Output Pattern

```
src/
├── components/
│   ├── KPICard.tsx
│   ├── KPICard_readme.md          ← Documentation lives here
│   ├── AlertFeed.tsx
│   └── AlertFeed_readme.md
├── hooks/
│   ├── useDashboard.ts
│   ├── useDashboard_readme.md     ← Hook documentation
│   └── useAuth.ts
└── services/
    ├── apiClient.ts
    └── apiClient_readme.md        ← Service documentation
```

## When to Use

- Documenting individual components, hooks, utilities, or services
- Creating API documentation for modules
- Documenting complex business logic
- Providing usage examples for reusable code units

## When NOT to Use

- Project-level documentation (use `docs/` folder)
- Architecture decisions (use ADRs)
- Getting started guides (use root README)
- Changelogs or release notes

## Input Parameters

| Parameter | Required | Description |
|-----------|----------|-------------|
| `TARGET` | Yes | Path to file or folder to document |
| `TYPE` | No | Type hint: `component`, `hook`, `service`, `utility`, `module` |
| `DEPTH` | No | How comprehensive: `brief`, `standard`, `comprehensive` |

## Procedure

### 1. Identify Target

```
IF TARGET is a file:
  UNIT_NAME = filename without extension
  UNIT_PATH = file directory
  UNIT_TYPE = infer from filename/content (hook, component, etc.)
ELSE IF TARGET is a folder:
  List all code files in folder
  Process each file that doesn't have a _readme.md
```

### 2. Analyze Code Unit

For each code unit:

1. **Read the source file** to understand:
   - Purpose and responsibility
   - Exported functions/components
   - Input parameters and types
   - Return values and types
   - Dependencies and imports
   - Side effects

2. **Identify existing documentation**:
   - JSDoc comments
   - Inline comments
   - Type definitions
   - Existing README in same folder

3. **Check for traceability headers**:
   - Module ID (MOD-XXX)
   - Task ID (T-NNN)

### 3. Generate Documentation

Create `<unit_name>_readme.md` with structure based on `TYPE`:

#### Component Documentation Template

```markdown
# {ComponentName}

> {One-line description from JSDoc or inferred}

## Overview

{Brief explanation of what this component does and when to use it}

## Props

| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| {prop} | {type} | {yes/no} | {default} | {description} |

## Usage

```tsx
import { {ComponentName} } from './{ComponentName}'

<{ComponentName}
  {prop}={value}
/>
```

## Examples

### Basic Usage
{code example}

### With Options
{code example with optional props}

## Accessibility

- {ARIA attributes used}
- {Keyboard interactions}
- {Screen reader considerations}

## Related

- [{RelatedComponent}](./{RelatedComponent}.tsx)
- [{RelatedHook}](../hooks/{hook}.ts)

---
*Generated by Unit_Documentation skill*
*Traceability: {MOD-ID} / {T-ID}*
```

#### Hook Documentation Template

```markdown
# {useHookName}

> {One-line description}

## Overview

{Brief explanation of the hook's purpose}

## Returns

```typescript
interface {UseHookNameReturn} {
  {property}: {type}  // {description}
}
```

| Property | Type | Description |
|----------|------|-------------|
| {property} | {type} | {description} |

## Usage

```typescript
import { {useHookName} } from './{useHookName}'

function MyComponent() {
  const { data, isLoading, error } = {useHookName}()

  // ...
}
```

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| {param} | {type} | {yes/no} | {description} |

## Examples

### Basic Usage
{code example}

### With Error Handling
{code example}

## Dependencies

- {dependency}: {why needed}

## State Management

{Description of internal state and how it's managed}

## Side Effects

- {side effect description}

---
*Generated by Unit_Documentation skill*
*Traceability: {MOD-ID} / {T-ID}*
```

#### Service/Utility Documentation Template

```markdown
# {ServiceName}

> {One-line description}

## Overview

{Brief explanation of the service's purpose}

## API Reference

### {functionName}

```typescript
{function signature}
```

{Description}

**Parameters:**
| Parameter | Type | Description |
|-----------|------|-------------|
| {param} | {type} | {description} |

**Returns:** `{returnType}` - {description}

**Example:**
```typescript
{example}
```

## Configuration

{Any configuration options or environment variables}

## Error Handling

{How errors are handled, error types thrown}

## Dependencies

{External dependencies and why they're needed}

---
*Generated by Unit_Documentation skill*
*Traceability: {MOD-ID} / {T-ID}*
```

### 4. Write Documentation File

1. Determine output path: `{UNIT_PATH}/{UNIT_NAME}_readme.md`
2. Check if file already exists:
   - If exists: Read and preserve user-added sections
   - If not: Create new file
3. Write documentation using appropriate template
4. Log creation: `Created: {path}/{name}_readme.md`

### 5. Validation

After creating documentation:

1. Verify markdown is valid
2. Check all code examples have correct syntax
3. Verify linked files exist
4. Ensure no placeholder text remains

## Depth Levels

### Brief
- Overview section only
- Basic usage example
- Props/returns table

### Standard (default)
- All sections from template
- 2-3 examples
- Accessibility notes
- Related links

### Comprehensive
- All standard sections
- Extended examples for all use cases
- Implementation notes
- Performance considerations
- Testing guidance
- Troubleshooting section

## Error Handling

| Scenario | Action |
|----------|--------|
| File not found | Log error, skip to next |
| Cannot parse TypeScript | Use basic template, note limitation |
| No exports found | Document the file as internal utility |
| Already has _readme.md | Skip unless `--force` flag |

## Integration with Traceability

The skill reads traceability headers from source files:

```typescript
// MOD-DSK-DASH-01: Operations Dashboard
// T-010: KPICard component
```

And includes them in generated documentation for full traceability chain.

## Example Invocations

```bash
# Document a single component
/document src/desktop/components/KPICard.tsx

# Document all hooks in a folder
/document src/mobile/hooks/

# Brief documentation for utility
/document src/shared/utils/formatters.ts --depth brief

# Comprehensive documentation for API client
/document src/shared/api/client.ts --depth comprehensive
```

## Output Summary

After execution, skill outputs:

```
Unit Documentation Complete
===========================
Target: {TARGET}
Type: {TYPE}
Depth: {DEPTH}

Created:
  - src/components/KPICard_readme.md
  - src/components/AlertFeed_readme.md

Skipped (already exists):
  - src/components/Button_readme.md

Errors:
  - None
```
