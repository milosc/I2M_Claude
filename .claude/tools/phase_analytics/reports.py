#!/usr/bin/env python3
"""
Report generators for Phase Execution Time Analytics.

Generates:
- Markdown reports with ASCII charts and Mermaid diagrams
- Summary reports for quick overview
"""

from datetime import datetime
from typing import Dict, List, Any, Optional


class MarkdownReport:
    """Generates Markdown analytics reports."""

    def generate(self, system_name: str, benchmark: Dict[str, Any],
                 current_run: Optional[Dict[str, Any]] = None,
                 comparisons: Optional[Dict[str, Any]] = None) -> str:
        """Generate a comprehensive Markdown report."""

        lines = [
            f"# Phase Execution Time Analytics Report",
            f"",
            f"**System**: {system_name}",
            f"**Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"**Report Version**: 1.0.0",
            f"",
            "---",
            ""
        ]

        # Executive Summary
        lines.extend(self._generate_summary(benchmark))

        # Stage Breakdown
        lines.extend(self._generate_stage_breakdown(benchmark))

        # Checkpoint Details
        lines.extend(self._generate_checkpoint_details(benchmark))

        # Agent Performance
        lines.extend(self._generate_agent_performance(benchmark))

        # Command Performance
        lines.extend(self._generate_command_performance(benchmark))

        # Trend Analysis
        lines.extend(self._generate_trend_analysis(benchmark))

        # Current Run Comparison (if available)
        if current_run and comparisons:
            lines.extend(self._generate_comparison_section(current_run, comparisons))

        # Bottleneck Analysis
        lines.extend(self._generate_bottleneck_analysis(benchmark))

        # Footer
        lines.extend([
            "---",
            "",
            f"*Report generated by HTEC Phase Execution Time Analytics v1.0.0*"
        ])

        return "\n".join(lines)

    def _generate_summary(self, benchmark: Dict[str, Any]) -> List[str]:
        """Generate executive summary section."""
        lines = [
            "## Executive Summary",
            "",
        ]

        stages = benchmark.get("stages", {})
        history = benchmark.get("history", [])
        agents = benchmark.get("agents", {})
        commands = benchmark.get("commands", {})

        total_runs = sum(s.get("runs_count", 0) for s in stages.values())
        total_stage_time = sum(s.get("avg_duration_seconds", 0) for s in stages.values())

        lines.append("| Metric | Value |")
        lines.append("|--------|-------|")
        lines.append(f"| Total Runs Analyzed | {total_runs} |")
        lines.append(f"| Stages with Data | {len(stages)} |")
        lines.append(f"| Unique Agents | {len(agents)} |")
        lines.append(f"| Unique Commands | {len(commands)} |")
        lines.append(f"| Total Avg Pipeline Time | {self._format_duration(total_stage_time)} |")
        lines.append(f"| Last Updated | {benchmark.get('last_updated', 'N/A')[:19]} |")

        # Find fastest/slowest stages
        if stages:
            by_avg = sorted(
                [(k, v) for k, v in stages.items() if v.get("avg_duration_seconds", 0) > 0],
                key=lambda x: x[1].get("avg_duration_seconds", 0)
            )
            if by_avg:
                lines.append(f"| Fastest Stage | {by_avg[0][0]} ({self._format_duration(by_avg[0][1].get('avg_duration_seconds', 0))}) |")
                lines.append(f"| Slowest Stage | {by_avg[-1][0]} ({self._format_duration(by_avg[-1][1].get('avg_duration_seconds', 0))}) |")

        lines.append("")
        return lines

    def _generate_stage_breakdown(self, benchmark: Dict[str, Any]) -> List[str]:
        """Generate stage-by-stage breakdown."""
        lines = [
            "## Stage Execution Times",
            "",
            "| Stage | Runs | Avg Time | Min | Max | Std Dev | Trend |",
            "|-------|------|----------|-----|-----|---------|-------|"
        ]

        stages = benchmark.get("stages", {})
        stage_order = ["discovery", "prototype", "productspecs", "solarch", "implementation"]

        for stage_name in stage_order:
            data = stages.get(stage_name, {})
            if not data or data.get("runs_count", 0) == 0:
                continue

            lines.append(
                f"| {stage_name.capitalize()} | "
                f"{data.get('runs_count', 0)} | "
                f"{self._format_duration(data.get('avg_duration_seconds', 0))} | "
                f"{self._format_duration(data.get('min_duration_seconds', 0))} | "
                f"{self._format_duration(data.get('max_duration_seconds', 0))} | "
                f"{self._format_duration(data.get('stddev_seconds', 0))} | "
                f"{self._trend_emoji(data.get('trend', 'stable'))} {data.get('trend', 'stable')} |"
            )

        lines.append("")

        # ASCII bar chart
        lines.extend(self._generate_ascii_chart(stages))

        return lines

    def _generate_ascii_chart(self, stages: Dict[str, Any]) -> List[str]:
        """Generate ASCII bar chart for stage comparison."""
        lines = [
            "### Visual Comparison",
            "",
            "```"
        ]

        valid_stages = {k: v for k, v in stages.items() if v.get("avg_duration_seconds", 0) > 0}

        if not valid_stages:
            lines.append("No data available")
            lines.append("```")
            lines.append("")
            return lines

        max_duration = max(s.get("avg_duration_seconds", 0) for s in valid_stages.values())
        if max_duration == 0:
            max_duration = 1

        bar_width = 40
        stage_order = ["discovery", "prototype", "productspecs", "solarch", "implementation"]

        for stage_name in stage_order:
            data = valid_stages.get(stage_name, {})
            if not data:
                continue

            duration = data.get("avg_duration_seconds", 0)
            bar_length = int((duration / max_duration) * bar_width)
            bar = "\u2588" * bar_length + "\u2591" * (bar_width - bar_length)

            lines.append(f"{stage_name:15} |{bar}| {self._format_duration(duration)}")

        lines.append("```")
        lines.append("")
        return lines

    def _generate_checkpoint_details(self, benchmark: Dict[str, Any]) -> List[str]:
        """Generate checkpoint-level details if available."""
        lines = [
            "## Checkpoint Breakdown",
            "",
        ]

        # Get checkpoint data from the most recent run in history
        history = benchmark.get("history", [])
        if not history:
            lines.append("*No checkpoint data available*")
            lines.append("")
            return lines

        # Group by stage and show average checkpoint times
        lines.append("*Checkpoint times shown are from the most recent runs.*")
        lines.append("")

        return lines

    def _generate_agent_performance(self, benchmark: Dict[str, Any]) -> List[str]:
        """Generate agent performance section."""
        lines = [
            "## Agent Performance",
            "",
        ]

        agents = benchmark.get("agents", {})
        if not agents:
            lines.append("*No agent data available*")
            lines.append("")
            return lines

        lines.append("| Agent | Invocations | Avg Time | Trend |")
        lines.append("|-------|-------------|----------|-------|")

        # Sort by total invocations
        sorted_agents = sorted(
            agents.items(),
            key=lambda x: x[1].get("total_invocations", 0),
            reverse=True
        )

        for agent_name, data in sorted_agents[:15]:  # Top 15
            lines.append(
                f"| `{agent_name}` | "
                f"{data.get('total_invocations', 0)} | "
                f"{self._format_duration(data.get('avg_duration_seconds', 0))} | "
                f"{self._trend_emoji(data.get('trend', 'stable'))} |"
            )

        if len(sorted_agents) > 15:
            lines.append(f"| *... and {len(sorted_agents) - 15} more* | | | |")

        lines.append("")
        return lines

    def _generate_command_performance(self, benchmark: Dict[str, Any]) -> List[str]:
        """Generate command performance section."""
        lines = [
            "## Command Performance",
            "",
        ]

        commands = benchmark.get("commands", {})
        if not commands:
            lines.append("*No command data available*")
            lines.append("")
            return lines

        lines.append("| Command | Invocations | Avg Time | Trend |")
        lines.append("|---------|-------------|----------|-------|")

        sorted_commands = sorted(
            commands.items(),
            key=lambda x: x[1].get("total_invocations", 0),
            reverse=True
        )

        for cmd_name, data in sorted_commands[:10]:
            lines.append(
                f"| `{cmd_name}` | "
                f"{data.get('total_invocations', 0)} | "
                f"{self._format_duration(data.get('avg_duration_seconds', 0))} | "
                f"{self._trend_emoji(data.get('trend', 'stable'))} |"
            )

        lines.append("")
        return lines

    def _generate_trend_analysis(self, benchmark: Dict[str, Any]) -> List[str]:
        """Generate trend analysis with Mermaid chart."""
        lines = [
            "## Trend Analysis",
            "",
        ]

        history = benchmark.get("history", [])
        if len(history) < 2:
            lines.append("*Insufficient data for trend analysis (need 2+ runs)*")
            lines.append("")
            return lines

        # Group by stage
        by_stage: Dict[str, List[Dict]] = {}
        for run in history:
            stage = run.get("stage")
            if stage:
                if stage not in by_stage:
                    by_stage[stage] = []
                by_stage[stage].append(run)

        # Text summary of trends
        lines.append("### Trend Summary")
        lines.append("")
        lines.append("| Stage | Runs | Trend | Direction |")
        lines.append("|-------|------|-------|-----------|")

        stages = benchmark.get("stages", {})
        for stage_name in ["discovery", "prototype", "productspecs", "solarch", "implementation"]:
            stage_data = stages.get(stage_name, {})
            if stage_data.get("runs_count", 0) > 0:
                trend = stage_data.get("trend", "stable")
                trend_desc = {
                    "improving": "Getting faster",
                    "degrading": "Getting slower",
                    "stable": "Consistent",
                    "insufficient_data": "Need more data"
                }.get(trend, "Unknown")

                lines.append(
                    f"| {stage_name.capitalize()} | "
                    f"{stage_data.get('runs_count', 0)} | "
                    f"{self._trend_emoji(trend)} | "
                    f"{trend_desc} |"
                )

        lines.append("")

        # Generate Mermaid line chart if we have data
        if len(history) >= 2:
            lines.extend(self._generate_mermaid_trend_chart(history, by_stage))

        return lines

    def _generate_mermaid_trend_chart(self, history: List[Dict], by_stage: Dict[str, List[Dict]]) -> List[str]:
        """Generate Mermaid xychart for trends."""
        lines = [
            "### Execution Time Trend Chart",
            "",
            "```mermaid",
            "xychart-beta",
            '    title "Execution Time Trends (minutes)"',
        ]

        # Find all unique dates
        all_dates = sorted(set(r.get("captured_at", "")[:10] for r in history if r.get("captured_at")))
        recent_dates = all_dates[-10:]  # Last 10 dates

        if not recent_dates:
            return ["*No trend data available*", ""]

        # Format dates for display
        date_labels = [f'"{d}"' for d in recent_dates]
        lines.append(f"    x-axis [{', '.join(date_labels)}]")

        # Find y-axis range
        all_durations = [r.get("duration_seconds", 0) / 60 for r in history if r.get("duration_seconds")]
        if all_durations:
            max_y = int(max(all_durations) * 1.2) + 1
        else:
            max_y = 100
        lines.append(f'    y-axis "Duration (minutes)" 0 --> {max_y}')

        # Add line for each stage
        for stage, runs in by_stage.items():
            sorted_runs = sorted(runs, key=lambda x: x.get("captured_at", ""))
            date_to_duration = {r.get("captured_at", "")[:10]: r.get("duration_seconds", 0) / 60
                                for r in sorted_runs}

            values = []
            for d in recent_dates:
                val = date_to_duration.get(d)
                if val is not None:
                    values.append(f"{val:.1f}")
                else:
                    values.append("0")  # Mermaid needs a value

            if any(float(v) > 0 for v in values):
                lines.append(f"    line [{', '.join(values)}]")

        lines.append("```")
        lines.append("")

        return lines

    def _generate_comparison_section(self, current_run: Dict[str, Any],
                                     comparisons: Dict[str, Any]) -> List[str]:
        """Generate current run comparison section."""
        lines = [
            "## Current Run Analysis",
            "",
            f"**Run ID**: {current_run.get('run_id', 'N/A')}",
            f"**Stage**: {current_run.get('stage', 'N/A')}",
            f"**Duration**: {self._format_duration(current_run.get('timing', {}).get('total_duration_seconds', 0))}",
            f"**Captured**: {current_run.get('captured_at', 'N/A')[:19]}",
            "",
        ]

        stage_comp = comparisons.get("stage", {})
        comparison = stage_comp.get("comparison", "unknown")
        delta = stage_comp.get("delta_percent", 0)

        if comparison == "faster":
            lines.append(f"### Performance: Faster than average")
            lines.append(f"This run completed **{abs(delta):.1f}% faster** than the benchmark average.")
        elif comparison == "slower":
            lines.append(f"### Performance: Slower than average")
            lines.append(f"This run took **{abs(delta):.1f}% longer** than the benchmark average.")
        elif comparison == "similar":
            lines.append(f"### Performance: Within normal range")
            lines.append(f"This run is within **{abs(delta):.1f}%** of the benchmark average.")
        else:
            lines.append(f"### Performance: First run")
            lines.append(f"This is the first recorded run for this stage - establishing baseline.")

        lines.append("")
        return lines

    def _generate_bottleneck_analysis(self, benchmark: Dict[str, Any]) -> List[str]:
        """Generate bottleneck analysis section."""
        lines = [
            "## Bottleneck Analysis",
            "",
        ]

        agents = benchmark.get("agents", {})
        commands = benchmark.get("commands", {})

        if not agents and not commands:
            lines.append("*No data available for bottleneck analysis*")
            lines.append("")
            return lines

        # Find top time consumers
        sorted_agents = sorted(
            agents.items(),
            key=lambda x: x[1].get("avg_duration_seconds", 0) * x[1].get("total_invocations", 0),
            reverse=True
        )[:5]

        if sorted_agents:
            lines.append("### Top Time-Consuming Agents")
            lines.append("")
            lines.append("| Agent | Total Time | Invocations | Impact |")
            lines.append("|-------|------------|-------------|--------|")

            total_agent_time = sum(
                a.get("avg_duration_seconds", 0) * a.get("total_invocations", 0)
                for a in agents.values()
            )

            for name, data in sorted_agents:
                agent_time = data.get("avg_duration_seconds", 0) * data.get("total_invocations", 0)
                impact = (agent_time / total_agent_time * 100) if total_agent_time > 0 else 0
                lines.append(
                    f"| `{name}` | "
                    f"{self._format_duration(agent_time)} | "
                    f"{data.get('total_invocations', 0)} | "
                    f"{impact:.1f}% |"
                )

            lines.append("")

        return lines

    def _format_duration(self, seconds: float) -> str:
        """Format seconds as human-readable duration."""
        if seconds is None or seconds == 0:
            return "-"
        if seconds < 60:
            return f"{seconds:.1f}s"
        elif seconds < 3600:
            minutes = seconds / 60
            return f"{minutes:.1f}m"
        else:
            hours = seconds / 3600
            return f"{hours:.1f}h"

    def _trend_emoji(self, trend: str) -> str:
        """Get emoji for trend direction."""
        return {
            "improving": "\U0001F4C8",  # chart increasing
            "degrading": "\U0001F4C9",  # chart decreasing
            "stable": "\u27A1\uFE0F",    # right arrow
            "insufficient_data": "\u2753"  # question mark
        }.get(trend, "\u2753")


class SummaryReport:
    """Generates quick summary reports."""

    def generate(self, system_name: str, benchmark: Dict[str, Any]) -> str:
        """Generate a brief summary report."""
        lines = [
            f"## {system_name} - Quick Summary",
            "",
        ]

        stages = benchmark.get("stages", {})
        total_runs = sum(s.get("runs_count", 0) for s in stages.values())

        lines.append(f"**Total Runs**: {total_runs}")
        lines.append(f"**Last Updated**: {benchmark.get('last_updated', 'N/A')[:19]}")
        lines.append("")

        # Stage summary
        lines.append("| Stage | Avg Time | Trend |")
        lines.append("|-------|----------|-------|")

        for stage_name in ["discovery", "prototype", "productspecs", "solarch", "implementation"]:
            data = stages.get(stage_name, {})
            if data.get("runs_count", 0) > 0:
                trend = data.get("trend", "stable")
                emoji = {"improving": "\U0001F4C8", "degrading": "\U0001F4C9", "stable": "\u27A1\uFE0F"}.get(trend, "\u2753")
                lines.append(
                    f"| {stage_name.capitalize()} | "
                    f"{self._format_duration(data.get('avg_duration_seconds', 0))} | "
                    f"{emoji} |"
                )

        return "\n".join(lines)

    def _format_duration(self, seconds: float) -> str:
        if seconds < 60:
            return f"{seconds:.1f}s"
        elif seconds < 3600:
            return f"{seconds/60:.1f}m"
        else:
            return f"{seconds/3600:.1f}h"
